\documentclass[12pt,twoside,a4paper]{article}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc} \usepackage{graphicx}

\usepackage{listings}
\lstloadlanguages{Matlab,C}
\lstset{% general command to set parameter(s)
basicstyle=\sffamily\footnotesize, % print whole listing small
keywordstyle=\sffamily\footnotesize\bfseries, % ubold black keywords
identifierstyle=, % nothing happens
commentstyle=\sffamily\footnotesize\slshape, % green comments
stringstyle=\sffamily\footnotesize, % typewriter type for strings
showstringspaces=false, % no special string spaces
%numbers=left,
numberstyle=\sffamily\footnotesize,
stepnumber=1,
numbersep=10pt,
showspaces=false,
showtabs=false,
%frame=lines,
morecomment=[l]{\%},
float=htbp,
numberbychapter=true
}
\setlength\parindent{0pt} 
\begin{document}

Subtraktion von binären Zahlen

Drei Schritte zu Subtraktion:

Das Einerkomplement
Das Zweierkomplement
Die Subtraktion von Dualzahlen

Einerkomplement

Was ist das Komplement von Dualzahlen? Man bildet das sogenannte Einerkomplement, indem man jede Zahl durch ihr Gegenteil ersetzt, also die 0 durch die 1 und die 1 durch die 0.

01011010 wird zu 10100101
11101101 wird zu 00010010

\paragraph{Das Zweierkomplement}

Das Zweierkomplement entspricht dem Einerkomplement, nur wird zusätzlich noch 00000001 addiert.

01011010 wird im Einerkomplement zu 10100101 im Zweierkomplement zu 10100110
11101101 wird im Einerkomplement zu 00010010 im Zweierkomplement zu 00010011

\paragraph{Konvertierung von Festkommazahlen Dez zu Bin}

10,2 \\
\\

Vorkommastelle
10 = 1010

Nachkommastelle\\
\emph{0,2} * 2 = 0,4 + 0 \emph{MSB} \\ 
0,4 * 2 = 0,8 + 0\\
0,8 * 2 = 0,6 + 1\\
0,6 * 2 = \emph{0,2} + 1 \emph{LSB} \\ 

Sobald es sich wiederholt kann aufgehört werden.\\
0, 2 = 0,0011\\
10,2 $\^=$ 1010,00110011 $\approx$ 0,19921875
\\
\Longrightarrow Eine Abweichung von  -0,00078125
\\
\paragraph{Konvertierung von Fließkommazahlen Dez zu Bin}
18,4_{10}


\item {18_{10}  \^= 10010_{2}} 
\item {0,4_{10} \^= 0,011_{2}}
\end






\paragraph{Die Subtraktion von Dualzahlen}

Der Satz lautet: Die Subtraktion von 2 Zahlen erfolgt durch die Addition des Zweierkomplementes. Als konkretes Beispiel nehmen wir dazu die Rechnung 14-9=5.

9 ist im Dualsystem 00001001.
Das Einerkomplement zu 00001001 ist 11110110.
Das Zweierkomplement 11110111.
Dies addieren wir nun zu 14 also 00001110.

   00001110 
  +11110111 
   ========
   00000101

Auch hier wäre die richtige Zahl eigentlich 00000101 Übertrag 1, da wir den Übertrag jedoch nicht speichern können, bleiben wir bei 00000101 was ja der Dezimalzahl 5 entspricht.

\paragraph{Little-/Bigendian}
\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{big-endian_und_little-endian.jpg}
\caption{A simple caption \label{overflow}}
\end{figure}

\section*{Assemblerbefehle}
\begin{lstlisting}
AREA MyCommonBlock, COMMON, ALIGN = 10 ; Read-Write-Data
MyCommonBlock bezeichnet die Anfangsadresse des Speicherblocks
COMMON: vom Linker mit Nullen initialisierter Speicherbereich
Alignment mit 2^{10} erzeugt eine Blockgrenze bzw. –anfang mit n * 1024

mov r0, #0x21
Lade #0x21 in Register R0:
R0
00000021
\end{lstlisting} 

\subparagraph{Angabe negativer Konstanten}
mov r1, #-10

\paragraph{Speicherreservierung}
DCB  8 Bit
DCW 16 Bit
DCD 32 Bit

\newpage
\section*{Lösungen für Tests}
\section{Lösung für Test 1:}
\section{Lösung für Test 2:}
\subsection{}
Aufgabe:\\
Die \textbf{vorzeichenlose} Zahl in r0 soll durch 4 geteilt werden. Das Ergebnis soll in r1 stehen.\\
Geben Sie den Befehl an:\\


\paragraph*{Lösung:}\\

\begin{lstlisting}
MOV r0,r1,ASR #2
\end{lstlisting}


\paragraph*{Erklärung:}
Eine Verschiebeoperation nach \textbf{links} um 1 Bit entspricht der \textbf{Multiplikation} mit 2 \\
und eine Verschiebeoperation nach \textbf{rechts} um 1 Bit entspricht der \textbf{Division} mit 2. \\
Warum \# 2 statt 4? \# 1 $\rightarrow$ x $\div$ 2; \# 2 $\rightarrow$ x $\div$ 2 $\div$ 2 $\rightarrow$ x $\div$ 4 


\paragraph*{Nachschlagen:}
Kapitel 8.5.5

\subsection{}
Aufgabe:\\
Das Datenfeld Var1 beginne bei Adresse 0x2000. Welcher Wert (hex.) vsteht nach Ausführung des Befehls in r0?\\

\begin{lstlisting}
Var1 	DCB 	10, 'A', 0xA, '1'

		ldr r0, =Var1
\end{lstlisting}

\paragraph*{Lösung}
r0 = 0x2000

\paragraph*{Erklärung:}
Lade die Adresse von Var1 in r0. 


\paragraph*{Nachschlagen:}
Kapitel 7.5.3

\subsection{}
Das Datenfeld Tab beginne bei Adresse 0x2000. Geben Sie die Speicherinhalte (hex.) von Adresse 0x2000 - 0x2003 an?\\
\begin{lstlisting}
Var1 	DCB 	0x10, 'A', 10, '1'
\end{lstlisting}

\paragraph*{Lösung}
0x2000: 41 31 0A 10 \\


\paragraph*{Erklärung:}
\\
0x10 $\rightarrow$ Hexadezimal $\rightarrow$ 10\\
'A' $\rightarrow$ ASCII $\rightarrow$ 41\\
10 $\rightarrow$ Hexadezimal $\rightarrow$ A\\
'1' $\rightarrow$ ASCII $\rightarrow$ 41\\

\paragraph*{Nachschlagen:}\\
Kapitel 7.4.3 Folie 18 $\rightarrow$ Wie werden die Sachen gespeichert?\\
Kapitel 6.4 $\rightarrow$ Reihenfolge im Speicher\\

\subsection{}
Folgendes Datenfeld sei gegeben:
\begin{lstlisting}
Var1 	DCD 	0x10, 0xAA12
\end{lstlisting}
Geben Sie die Assemblerbefehle an, um das \underline{erste Datenwort} des Feldes Var1 nach r1 zu kopieren

\paragraph*{Lösung:}
\begin{lstlisting}
ldr r0, =WortFeld ; Arraystartadresse laden 
ldr r1, [r0] ; Erstes Element des Arrays
\end{lstlisting}
\paragraph*{Erklärung:}
Warum nicht mov?\\
mov kopiert nur ein Datenwort Syntax: MOV <wohin>, <woher,was> $\rightarrow$ Wir haben hier ein Datenfeld, daher unbrauchbar\\
Nachschlagen von MOV: Kapitel 6.9.3\\
\paragraph*{Nachschlagen:}
Kapitel 7.5.3
Kapitel 7.7.3


\subsection{}
Was steht in r0 nach folgendem Befehl (hex.)?
\begin{lstlisting}
ldr 		r0, =0x1234ABCD
\end{lstlisting}


\paragraph*{Lösung:}
r0 = 0x1234ABCD

\paragraph*{Erklärung:} 
Wenn nach '=' ein Hexwert kommt dann speichere den Wert. Wenn Variable, dann speichere die Adresse.\\


\paragraph*{Nachschlagen:}
http://www.keil.com/support/man/docs/armasm/armasm_dom1361289875065.htm\\
https://www.raspberrypi.org/forums/viewtopic.php?&t=16528

\subsection{}
In welchem Wertebereich muss r0 liegen, damit ein Sprung nach LOOP erfolgt? (dezimal oder hex.)
\begin{lstlisting}
mov		r1, #-15
cmp		r0, r1
bge		LOOP	;if greater or equal
\end{lstlisting}


\paragraph*{Lösung:}

\paragraph*{Erklärung:}

\paragraph*{Nachschlagen:}

\subsection{}
Was steht in r0 nach folgender Befehlssequenz (hex.)?
\begin{lstlisting}
ldr		r1, =0xFFFFFF87
mov		r0, #0x78
and		r0, r1
\end{lstlisting}


\paragraph*{Lösung:}

\paragraph*{Erklärung:}

\paragraph*{Nachschlagen:}


\end{document}
